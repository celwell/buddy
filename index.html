<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>buddy documentation</title>
<link rel="stylesheet" href="static/niwi.css" type="text/css">
<link rel="stylesheet" href="static/pygments.css" type="text/css">


<script type="text/javascript" src="static/asciidoc.js"></script>
<script type="text/javascript" src="static/niwi.js"></script>
<script type="text/javascript">
/*<![CDATA[*/
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article" style="max-width:800px">
<div id="header">
<h1>buddy documentation</h1>
<span id="author">Andrey Antukh,</span><br>
<span id="email" class="monospaced">&lt;<a href="mailto:niwi@niwi.be">niwi@niwi.be</a>&gt;</span><br>
<span id="revnumber">version 0.1.0,</span>
<span id="revdate">2014-01-19</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>buddy</em> is an authentication, authorization and signing library for
Clojure.  It&#8217;s designed with simplicity in mind and only depends on
ring.</p></div>
<div class="paragraph"><p>Features/Libraries:</p></div>
<div class="ulist"><ul>
<li>
<p>
Modular Authentication (implemented using protocols)
</p>
</li>
<li>
<p>
Modular Generic Authorization
</p>
</li>
<li>
<p>
Regular expression based access rules system
</p>
</li>
<li>
<p>
Signing library
</p>
</li>
<li>
<p>
Password hashing library
</p>
</li>
</ul></div>
<div class="paragraph"><p><a href="api/index.html">API reference documentation.</a></p></div>
<div class="sect2">
<h3 id="_philosophy">1.1. Philosophy</h3>
<div class="paragraph"><p>Five most important rules:</p></div>
<div class="ulist"><ul>
<li>
<p>
Beautiful is better than ugly
</p>
</li>
<li>
<p>
Explicit is better than implicit
</p>
</li>
<li>
<p>
Simple is better than complex
</p>
</li>
<li>
<p>
Readability counts
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_project_maturity">2. Project Maturity</h2>
<div class="sectionbody">
<div class="paragraph"><p>Since <em>buddy</em> is a young project there can be some API breakage.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_install">3. Install</h2>
<div class="sectionbody">
<div class="paragraph"><p>This section covers installing <em>buddy</em>.</p></div>
<div class="sect2">
<h3 id="_leiningen">3.1. Leiningen</h3>
<div class="paragraph"><p>The simplest way to use <em>buddy</em> in a Clojure project is by including
it as a dependency in your <strong><em>project.clj</em></strong>:</p></div>
<div class="listingblock">
<div class="title"><em>in project.clj</em></div>
<div class="content"><div class="highlight"><pre><span class="p">[</span><span class="nv">buddy</span> <span class="s">&quot;0.1.0-beta4&quot;</span><span class="p">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_maven">3.2. Maven</h3>
<div class="paragraph"><p>Also, you can use it with maven. First, add the clojars repository:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="nt">&lt;repository&gt;</span>
    <span class="nt">&lt;id&gt;</span>clojars.org<span class="nt">&lt;/id&gt;</span>
    <span class="nt">&lt;url&gt;</span>http://clojars.org/repo<span class="nt">&lt;/url&gt;</span>
<span class="nt">&lt;/repository&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Then for buddy:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>buddy<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>buddy<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>0.1.0-beta4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide">4. User guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_signing">4.1. Signing</h3>
<div class="paragraph"><p>The "signing framework" of <em>buddy</em> is mainly based on django&#8217;s
<a href="https://docs.djangoproject.com/en/1.6/topics/signing/">Cryptographic
signing</a> library.</p></div>
<div class="paragraph"><p>It can be used for several purposes:</p></div>
<div class="ulist"><ul>
<li>
<p>
Safely storing session data in cookies instead of a database (It prevents others from changing session content)
</p>
</li>
<li>
<p>
Self contained token generation for use it on completely stateless token based authentication.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">this library is used by one of authentication backends for implement token based stateless authentication.</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">hmac+sha256 is used for sign all data.</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_using_low_level_api">4.1.1. Using low level api</h4>
<div class="paragraph"><p>There are four signing functions in <strong><span class="monospaced">buddy.crypto.signing</span></strong>: <span class="monospaced">sign</span>,
<span class="monospaced">unsign</span>, <span class="monospaced">loads</span> and <span class="monospaced">dumps</span>.</p></div>
<div class="paragraph"><p><span class="monospaced">sign</span> and <span class="monospaced">unsign</span> are low level and work primarily with strings.</p></div>
<div class="listingblock">
<div class="title">Unsigning previously signed data</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">buddy.sign.generic</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">sign</span> <span class="nv">unsign</span><span class="p">]])</span>

<span class="c1">;; Sign data</span>
<span class="p">(</span><span class="k">def </span><span class="nv">signed-data</span> <span class="p">(</span><span class="nf">sign</span> <span class="s">&quot;mystring&quot;</span> <span class="s">&quot;my-secret-key&quot;</span><span class="p">))</span>

<span class="c1">;; signed-data should contain a string similar to:</span>
<span class="c1">;; &quot;mystring:f08dd937a438f43639d34a345910148cb933ea8ea0c2c306e8733e0255677e3d:MTM...&quot;</span>

<span class="c1">;; Unsign previosly signed data</span>
<span class="p">(</span><span class="k">def </span><span class="nv">unsigned-data</span> <span class="p">(</span><span class="nf">unsign</span> <span class="nv">signed-data</span> <span class="s">&quot;my-secret-key&quot;</span><span class="p">))</span>

<span class="c1">;; unsigned-data should contain the original string: &quot;mystring&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>The signing process consists of append signatures to the original
string, separating the signature with a predefined separator (default
":" char). The signature is timestamped hmac. <strong>Timestamp</strong> can be used
to invalidate some signed data by time.</p></div>
<div class="listingblock">
<div class="title">Invalidate signed data using timestamp</div>
<div class="content"><div class="highlight"><pre><span class="c1">;; Unsign with maxago (15min)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">unsigned-data</span> <span class="p">(</span><span class="nf">unsign</span> <span class="nv">signed-data</span> <span class="s">&quot;my-secret-key&quot;</span> <span class="p">{</span><span class="ss">:maxago</span> <span class="p">(</span><span class="nb">* </span><span class="mi">60</span> <span class="mi">15</span> <span class="mi">1000</span><span class="p">)}))</span>

<span class="c1">;; unsigned-data should contain a nil value if the signing date is</span>
<span class="c1">;; older than 15 min.</span>

<span class="nv">Protecting</span> <span class="nv">complex</span> <span class="nv">data</span> <span class="nv">structures</span>
<span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="nv">If</span> <span class="nv">you</span> <span class="nv">wish</span> <span class="nv">to</span> <span class="nv">protect</span> <span class="nv">a</span> <span class="nv">native</span> <span class="nv">data</span> <span class="nv">structure</span> <span class="p">(</span><span class="nf">hash-map</span>, <span class="nv">hash-set</span>,
<span class="nv">list</span>, <span class="nv">vector</span>, <span class="nv">etc...</span><span class="p">)</span>  <span class="nv">you</span> <span class="nv">can</span> <span class="k">do </span><span class="nv">so</span> <span class="nv">using</span> <span class="nv">the</span> <span class="nv">signing</span> <span class="nv">*</span><span class="o">`</span><span class="nv">dumps</span><span class="o">`</span><span class="nb">* </span><span class="nv">and</span>
<span class="nv">*</span><span class="o">`</span><span class="nv">loads</span><span class="o">`</span><span class="nb">* </span><span class="nv">functions.</span> <span class="nv">They</span> <span class="nv">accept</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">parameters</span> <span class="nv">as</span> <span class="nv">their</span> <span class="nv">friends</span>
<span class="p">(</span><span class="o">`</span><span class="nv">sign</span><span class="o">`</span> <span class="nb">and </span><span class="o">`</span><span class="nv">unsign</span><span class="o">`</span><span class="p">)</span>, <span class="nv">but</span> <span class="nv">can</span> <span class="nv">also</span> <span class="nv">sign</span> <span class="nv">more</span> <span class="nv">complex</span> <span class="nv">data.</span>

<span class="nv">.Sign/Unsign</span> <span class="nv">Clojure</span> <span class="nv">hash-map</span>
<span class="p">[</span><span class="nv">source</span>,<span class="nv">clojure</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>(require '[buddy.sign.generic :refer [dumps loads]])</p></div>
<div class="paragraph"><p>;; Sign data
(def signed-data (dumps {:userid 1} "my-secret-key"))</p></div>
<div class="paragraph"><p>;; signed-data should contain a string similar to:
;; "TlBZARlgGwAAAAIOAAAABnVzZXJpZCsAAAAAAAAAAQ:59d9e8063ad80f6abd3092b45857810b10f5&#8230;"</p></div>
<div class="paragraph"><p>;; Unsign previously signed data
(def unsigned-data (loads signed-data "my-secret-key"))</p></div>
<div class="paragraph"><p>;; unsigned-data should contain a original map: {:userid 1}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>NOTE: it uses a Clojure serialization library link:https://github.com/ptaoussanis/nippy[Nippy]

INFO: Currently only a generic sign method is available, but I am
working on a jwt (json web token) implementation for buddy. It will be
available in future releases.

Hashers
~~~~~~~

Another important part of a good authentication/authorization library
is providing some facilities for generating secure passwords. _buddy_
comes with a few functions for generating and verifying passwords like
the widely used password derivation algorithms bcrypt and pbkdf2 (with
sha256).

_buddy_ hashers live in `buddy.hashers.*` and usually consist
of `make-password` and `check-password`.

The purpose of these functions is obvious: creating a new password,
and verifying incoming plain text password with previously created
hash.

.Example of creating and verifying a new hash
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(require '[buddy.hashers.bcrypt :as hs])</p></div>
<div class="paragraph"><p>(def myhash (hs/make-password "secretpassword"))
(def ok (hs/check-password "secretpassword" myhash))</p></div>
<div class="paragraph"><p>;; ok var reference should contain true</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>[NOTE]
`make-password` accept distinct parameters depending on hasher implementation.

In previous example we use *bcrypt* hasher but _buddy_ also support many other
hasher algorithm by default.

This is a complete list of implemented hashers:

- `buddy.hashers.pbkdf2` (implements pbkdf2 with sha256)
- `byddy.hashers.bcrypt`
- `buddy.hashers.sha256`
- `buddy.hashers.md5`
- `buddy.hashers.scrypt`


Authentication
~~~~~~~~~~~~~~

_buddy_ comes with an authentication system. It is implemented with
protocols that can be used to implement your own authentication
backend if one of the now supported backends by buddy does not satisfy
your needs.

Here is a list of built-in authentication backends:

- Http Basic
- Session
- Token
- SignedToken (using previously explained signing framework).


HTTP Basic
^^^^^^^^^^

The HTTP Basic authentication backend is one of the simplest/insecure
authentication systems, but it works well as a first introduction of
authentication with _buddy_.

.Simple handler definition
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(require '[buddy.auth :refer (authenticated?)])
(require '[ring.util.response :refer (response)])</p></div>
<div class="paragraph"><p>;; Simple ring handler. This can also be a compojure routes handler
;; or anything else compatible with ring middlewares.
(defn handler
  [request]
  (if (authenticated? request)
    (response (format "Hello %s" (:identity request)))
    (response "Hello Anonymous")))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>.Middleware usage example
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>;; Import middleware function and backend constructor</p></div>
<div class="paragraph"><p>(require '[buddy.auth.backends.httpbasic :refer [http-basic-backend]])
(require '[buddy.auth.middleware :refer [wrap-authentication]])</p></div>
<div class="paragraph"><p>;; This function always receives request and authdata, authdata
;; can vary with other backends. For http basic backend, authdata
;; parameter has the form {:username xxxx :password yyyy}
;;
;; This function should return a non-nil value that
;; is automatically stored on :identity key on request
;; If it returns nil, a request is considered unauthenticated.</p></div>
<div class="paragraph"><p>(defn my-authfn
  [request, authdata]
  (let [username (:username authdata)
        password (:password authdata)]
    (search-user-on-db username password)))</p></div>
<div class="paragraph"><p>;; Define the main handler with <strong>app</strong> name wrapping it
;; with authentication middleware using an instance of
;; just created http-basic backend.</p></div>
<div class="paragraph"><p>(def app (let [backend (http-basic-backend :realm "MyApi" :authfn my-authfn)]
           (wrap-authentication handler backend)))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Session
^^^^^^^

A session-authenticated backend has the simplest implementation
comparing it with others, but it requires session middleware to
properly work.

Unlike the previous auth backend, this does not requires authfn,
because it relies on `:identity` key on session and trust it. If a
session contains the `:identity` key with logical true value it
identifies the current request as authenticated and put `:identity`
key on request map.

See xref:examples[examples section] for complete examples for this backend.


Token
^^^^^

It works as expected, parses token and call function for authenticate the token. Nothing
more.

Signed Token
^^^^^^^^^^^^

This works similar to *session* and *token* backends, but it uses a signing framework explained in a
first section of this document.

Extracts token from header using same functions as *token* backend but instad of call a function
for authorize or trust a session key, it try verify the incoming token and if it success, the signed
data are trustly set to `:identity` key on request.

See xref:examples[examples section] for complete examples for this backend.


Authorization
~~~~~~~~~~~~~

_buddy_ also comes with authorization system.

The authorization system is splited in two parts:

- generic authorization system using exceptions for fast return and unauthorized-handler function
  for handle unauthorized requsts.
- access rules system based on matching urls using regular expressions and apply some
  rules handlers. The idea is taken from `lib-noir` but with slighty distinct approach.


Generic authorization
^^^^^^^^^^^^^^^^^^^^^

This authorization system encapsulates your handlers/controllers in one try/catch block
catching only notauthorized exceptions. So spliting unauthorized request handling code from
your handlers/controllers in a separate function. Moreover, permits fast return when
not authorized request is detected.

Like authentication system, authorization is also implemented using protocols. Taking advantage of
it, all builtin authentication backends also implements this authorization protocol (`IAuthorization`).

Some authentication backends require specific behavior in the
authorization layer (like http-basic which should return
`WWW-Authenticate` header when request is unauthorized) and by
default, all backends come with an implementation. You can overwrite
the default behavior by passing your own exception handler through the
`:unauthorized-handler` keyword parameter in the backend constructor.

Below is a complete example setting up a basic/generic authorization
system for your ring compatible web application:


.Defining uathorized handler
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(require '[buddy.auth :refer [authenticated? throw-unauthorized]])
(require '[ring.util.response :refer (response redirect)])</p></div>
<div class="paragraph"><p>;; An unauthorized-handler is executed when <span class="monospaced">buddy.auth/throw-unauthorized</span>
;; exception is raised and captured by genric authorization middleware:
;; <span class="monospaced">wrap-authorization</span>. It always receives the current request and metadata
;; hash-map that in most cases is empty.</p></div>
<div class="paragraph"><p>(defn my-unauthorized-handler
  [request metadata]
  (if (authenticated? request)
    (response "Permission denied")
    (redirect "/login")))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>.Defining a simple handler that raises unauthorized exception when user is not authenticated
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>;; This is a simple ring compatible handler
(defn handler
  [request]
  (if (authenticated?)
    (response "Hello World")
    (throw-unauthorized)))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>.Define the final handler
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(require '[buddy.auth.backends.httpbasic :refer [http-basic-backend]])
(require '[buddy.auth.middleware :refer [wrap-authentication wrap-authorization]])</p></div>
<div class="paragraph"><p>;; Define the final handler wrapping it on authentication and
;; authorization handler using the same backend and overwriting
;; the default unathorized request behavior with own, previously
;; defined function</p></div>
<div class="paragraph"><p>(def app (let [backend (http-basic-backend
                         :realm "API"
                         :authfn my-auth-fn
                         :unauthorized-handler my-unauthorized-handler)]
           (&#8594; handler
               (wrap-authentication backend)
               (wrap-authorization backend))))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>NOTE: If you want know how it really works, see xref:how-it-works[How it works] section or
take a look on examples.


Access Rules System
^^^^^^^^^^^^^^^^^^^

Introduction
++++++++++++

Access rules is an other part of authorization system, and it consists on setting a list
of rules for a one or a set of uri's using regular expressions. One rule consists in one regular
expression with associated handler (function) with authorization logic.

.Simple rule example
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>{:pattern #"^/admin/.*"
 :handler admin-access}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Having the `admin-access` function like this:

[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(def users {:niwibe {:roles #{:admin}}
            :pepe {:roles #{:user}}})</p></div>
<div class="paragraph"><p>(defn admin-access
  [request]
  (let [identity (:identity request)]
    (if (nil? identity) false
      (let [roles (&#8594; identity users :roles)]
        (boolean (roles :admin))))))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>The handler function should receive a request and return true, false
or throw unauthorized exception. Throwing unauthorized exception is a
fast return method and no other handler is executed before it (only if
handler is wrapped with `wrap-authorization` middleware).

In the previous example we have seen a simple handler associated with
one regular expression, but _buddy_ access rules system allows combine
more handlers using logical `:and` &amp; `:or` combinators with nesting
support.

For example, suppose you want to allow access to a set of urls only to
operators or administrators:

[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>{:pattern #"^/admin/.*"
 :handler {:or [admin-access operator-access]}}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Or allow only when a user has both roles, operator and administrator:

[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>{:pattern #"^/admin/.*"
 :handler {:and [admin-access operator-access]}}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Even more, you want to only allow read-write access to administrators
and operators, and read-only access to any authenticated user:

[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>{:pattern #"^/admin/.*"
 :handler {:or [admin-access operator-access
               {:and [safemethod-access authenticated-access]}]}}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>How to use it?
++++++++++++++

Access rules system is flexible and adapting it is very simple for
many use cases.

The simplest way to use access rules is by using the
`wrap-access-rules` middleware with an ordered vector of
rules. *Important:* rules are evaluated in order, therefore, put less
restrictive regular expression at the end.

.Define a list of rules
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>;; Rules handlers used on this example are omited for code clarity
;; and them repsents a authorization logic for its name.</p></div>
<div class="paragraph"><p>(def rules [{:pattern #"<sup>/admin/.<strong>"
             :handler {:or [admin-access operator-access]}}
            {:pattern #"</sup>/login$"
             :handler any-access}
            {:pattern #"^/.</strong>"
             :handler authenticated-access}])</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>.Define default behavior for not authorized requests
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>;; This functions works like default ring compatible handler
;; and should implement the default behavior for request
;; that are not authorized by any defined rule</p></div>
<div class="paragraph"><p>(defn reject-handler
  [request]
  {:status 403
   :headers {}
   :body "Not authorized"})</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>.Wrap your handler with access rules (and run with jetty as example)
[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(defn -main
  [&amp; args]
  (let [app (wrap-access-rules your-app-handler
                               :rules rules
                               :reject-handler reject-handler))]
    (run-jetty app {:port 9090}))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>If no reject handler is specified, unauthorized exception is raised. These exception
can be captured by generic authorization middleware.


[NOTE]
The current request uri not match any regular expresion, the default policy enter in
action. The default policy in _buddy_ is `:allow` but you can change it to `:reject`
using keyword `:policy` on wrap-access-rules middleware.


An other way to use access rules is using `buddy.auth.accessrules/restrict`
handler decorator that allows assign some rules to concrete handlers omiting
any url matching.

The usage of it can be easy show using compojure routes:

[source,clojure]</pre>
</div></div>
<div class="paragraph"><p>(require '[buddy.auth.accessrules :refer [restrict]])</p></div>
<div class="paragraph"><p>(defroutes app
  (GET "/" [] (restrict my-home-ctrl
                        ;; Mandatory parameter
                        :rule user-access
                        ;; Optional parameter, in case if not passed
                        ;; default is used (defined by <span class="monospaced">wrap-access-rules</span>
                        ;; middleware) or <span class="monospaced">throw-unauthorized</span> is raised
                        ;; if default isn&#8217;t available
                        :reject-handler reject-handler))
  (GET "/admin" (restrict my-admin-ctrl
                          :rule admin-access)))</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Advanced Usage</pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="how-it-works">4.2. How It Works</h3>
<div class="paragraph"><p>Each backend implements two protocols: <span class="monospaced">IAuthentication</span> and <span class="monospaced">IAuthorization</span>.</p></div>
<div class="paragraph"><p><strong>IAuthentication</strong> provides two functions: <span class="monospaced">parse</span> and <span class="monospaced">authenticate</span>
and is automatically handled with <span class="monospaced">wrap-authentication</span> ring
middleware. This is an example flow for the http basic backend:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Received request is passed to <span class="monospaced">parse</span> function. This function extracts the <span class="monospaced">Authorization</span>
   header, decodes a base64 encoded string and returns Clojure map with <span class="monospaced">:username</span> and <span class="monospaced">:password</span>
   keys. If a parse error occured, it returns nil.
</p>
</li>
<li>
<p>
If the previous step parsed the token successfully, <span class="monospaced">authenticate</span> is called with current
   request and parsed data from previous step. <span class="monospaced">authenticate</span> can delegate authentication
   to user defined function passed as <span class="monospaced">:authfn</span> parameter to backend constructor.
   <span class="monospaced">authenticate</span> should return a request with <span class="monospaced">:identity</span> key assigned to nil or any other
   value. All requests with <span class="monospaced">:identity</span> key with nil value are considered not authenticated.
</p>
</li>
<li>
<p>
User handler is called.
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="ulist"><ul>
<li>
<p>
<span class="monospaced">parse</span> function can return valid response, in that case response is returned inmediatel
  ignoring user handler.
</p>
</li>
<li>
<p>
if <span class="monospaced">parse</span> function returns nil, <span class="monospaced">authenticate</span> function is ignored and user handler is
  called directly.
</p>
</li>
<li>
<p>
<span class="monospaced">authenticate</span> also can return a valid response, in these case it has same behavior that
  with <span class="monospaced">parse</span> function.
</p>
</li>
</ul></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p><strong>IAuthorization</strong> provides <span class="monospaced">handle-unauthorized</span> function. Each backend implements it default
behavior but it can be overwritted with user defined function, passed on <span class="monospaced">:handle-unauthorized</span>
keyword parameter to backend constructor. It always should return a valid response.</p></div>
<div class="paragraph"><p>Authorization is handled automatically with <span class="monospaced">wrap-authorization</span> ring middleware. It wraps
all request in try/catch block for intercept only authorization exception.</p></div>
<div class="paragraph"><p>This is a flow that follows authorization middleware:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
User handler is wrapped in try/catch block and executed.
</p>
</li>
<li>
<p>
Not authorized exception is raised with <span class="monospaced">buddy.auth/throw-unauthorized</span> function from
   any part of your handler.
</p>
</li>
<li>
<p>
handle-unauthorized is executed of your backend, if user has specified it own function,
   the user defined function is executed else, default behavior is executed.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_core_library">5. Core library</h2>
<div class="sectionbody">
<div class="paragraph"><p>Behind the scenes buddy, behind the scene uses internal library exposed in <span class="monospaced">buddy.core</span> namespace that exposes
more low level access over hash, hmac, coding functions that are used by other parts of buddy.</p></div>
<div class="sect2">
<h3 id="_cryptographic_hash_algorithms">5.1. Cryptographic hash algorithms</h3>
<div class="paragraph"><p>All implementation is found on <span class="monospaced">buddy.core.hash</span> namespace and exposes functions for access
to sha-2/md hash algorithms with two ways to work with them:</p></div>
<div class="paragraph"><p>This is buddy&#8217;s naming convention:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>make-&lt;hashalgo&gt;</strong>: functions that matches this pattern always return byte array.
</p>
</li>
<li>
<p>
<strong>&lt;hashalgo&gt;</strong>: functions that always return string that in almost all cases hex encoded.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Available hash algorithms:</strong></p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>sha256</strong>
</p>
</li>
<li>
<p>
<strong>sha384</strong>
</p>
</li>
<li>
<p>
<strong>sha512</strong>
</p>
</li>
<li>
<p>
<strong>sha1</strong>
</p>
</li>
<li>
<p>
<strong>md5</strong>
</p>
</li>
</ul></div>
<div class="sect3">
<h4 id="_basic_usage">5.1.1. Basic usage</h4>
<div class="listingblock">
<div class="title">Import namespace example:</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">buddy.core.hash</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">make-sha256</span>, <span class="nv">sha256</span><span class="p">]])</span>
</pre></div></div></div>
<div class="listingblock">
<div class="title">How to use examples:</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">sha256</span> <span class="s">&quot;foo bar&quot;</span><span class="p">)</span>
<span class="c1">;; -&gt; &quot;fbc1a9f858ea9e177916964bd88c3d37b91a1e84412765e29950777f265c4b75&quot;</span>

<span class="p">(</span><span class="nf">make-sha256</span> <span class="s">&quot;foo bar&quot;</span><span class="p">)</span>
<span class="c1">;; -&gt; #&lt;byte[] [B@162a657e&gt;</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="_advanced_usage">5.1.2. Advanced usage</h4>
<div class="paragraph"><p>Hash functions are implemented using protocols.  We have seen how to
hash strings, but note that the same function works for <strong>File</strong>, <strong>URL</strong>,
<strong>URI</strong> and <strong>InputStream</strong>.</p></div>
<div class="listingblock">
<div class="title">Make hash of file example:</div>
<div class="content"><div class="highlight"><pre><span class="c1">;; Additional import for easy open files</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>

<span class="p">(</span><span class="nf">sha256</span> <span class="p">(</span><span class="nf">io/input-stream</span> <span class="s">&quot;/tmp/some-file&quot;</span><span class="p">))</span>
<span class="c1">;; -&gt; &quot;bba878639499c8449f69efbfc699413eebfaf41d4b7a7faa560bfaf7e93a43dd&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>You can extend it for your own types by using the
<strong>buddy.core.hash/Digest</strong> protocol:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Digest</span>
  <span class="p">(</span><span class="nf">make-digest</span> <span class="p">[</span><span class="nv">data</span> <span class="nv">algorithm</span><span class="p">]))</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Functions like <strong>sha256</strong>/<strong>make-sha256</strong> are partials that works as alias for more generic
functions: <strong>digest</strong>  and <strong>make-digest</strong>.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hash_based_message_authentication">5.2. Hash-based message authentication</h3>
<div class="paragraph"><p>buddy comes with two variants of <strong>hmac</strong>: standard and salted. Both are
available in <span class="monospaced">buddy.core.hmac</span> namespace. They also follow the
<span class="monospaced">make-&lt;algo&gt;</span> naming convention.</p></div>
<div class="sect3">
<h4 id="_basic_usage_2">5.2.1. Basic usage</h4>
<div class="listingblock">
<div class="title">Import namespace</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">buddy.core.hmac</span> <span class="ss">:as</span> <span class="nv">hmac</span><span class="p">])</span>
</pre></div></div></div>
<div class="listingblock">
<div class="title">How to use standard hmac with string</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">hmac/hmac-sha256</span> <span class="s">&quot;foo bar&quot;</span> <span class="s">&quot;mysecretkey&quot;</span><span class="p">)</span>
<span class="c1">;; -&gt; &quot;61849448bdbb67b39d609471eead667e65b0d1b9e01b1c3bf7aa56b83e9c8083&quot;</span>
</pre></div></div></div>
<div class="listingblock">
<div class="title">How to use salted variant of hmac with string</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">hmac/salted-hmac-sha256</span> <span class="s">&quot;foo bar&quot;</span> <span class="s">&quot;salt&quot;</span> <span class="s">&quot;mysecretkey&quot;</span><span class="p">)</span>
<span class="c1">;; -&gt; &quot;bd5f7a0040430a73f4845bac8f980c6398b4baae8a22efcc22038be0f4dd9678&quot;</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">The key parameter can be any type that implements the currently
undocumented <strong>buddy.core.keys/ISecretKey</strong> protocol (buddy comes with
default implementations for String and byte[])</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_advanced_usage_2">5.2.2. Advanced usage</h4>
<div class="paragraph"><p>Like the other hash functions, hmac is implemented using Clojure
protocols and is implementated for: String, byte[], <strong>File</strong>, <strong>URL</strong>,
<strong>URI</strong> and <strong>InputStream</strong>.</p></div>
<div class="listingblock">
<div class="title">Make hmac of file</div>
<div class="content"><div class="highlight"><pre><span class="c1">;; Additional import for easy open files</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>

<span class="p">(</span><span class="nf">hmac/hmac-sha256</span> <span class="p">(</span><span class="nf">io/input-stream</span> <span class="s">&quot;/tmp/somefile&quot;</span><span class="p">)</span> <span class="s">&quot;mysecretkey&quot;</span><span class="p">)</span>
<span class="c1">;; -&gt;&quot;4cb793e600848da2053238003fce4c010233c49df3e6a04119b4287eb464c27e&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>You can extend it for your own types using <strong>buddy.core.hmac/HMac</strong> protocol that
looks like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">HMac</span>
  <span class="p">(</span><span class="nf">make-hmac</span> <span class="p">[</span><span class="nv">data</span> <span class="nb">key </span><span class="nv">algorithm</span><span class="p">]))</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Functions like <strong>hmac-sha256</strong> are just alias for more generic functions:
<strong>hmac</strong> and <strong>salted-hmac</strong>.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_codecs_binary_8594_string_conversion">5.3. Codecs (binary &#8594; string conversion)</h3>
<div class="paragraph"><p>TODO</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples">6. Examples</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>buddy</em> comes with some examples for helping a new user understand how
it works. All examples are available in the <span class="monospaced">examples/</span> directory.</p></div>
<div class="paragraph"><p>At the moment, two examples are available:</p></div>
<div class="ulist"><ul>
<li>
<p>
<a href="https://github.com/niwibe/buddy/tree/master/examples/sessionexample">Use session backend as authentication and authorization.</a>
</p>
</li>
<li>
<p>
<a href="https://github.com/niwibe/buddy/tree/master/examples/oauthexample">Use session backend with oauth2 using Github api.</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p>To run examples, you should be in the project&#8217;s root directory.
Execute <span class="monospaced">lein with-profile examplename run</span> where examplename can be
<span class="monospaced">sessionexample</span> or <span class="monospaced">oauthexample</span>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_contribute">7. How to contribute</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>buddy</em> does not have many restrictions for contributing.</p></div>
<div class="paragraph"><p><strong>For Bugfix</strong>:</p></div>
<div class="ulist"><ul>
<li>
<p>
Fork github repo.
</p>
</li>
<li>
<p>
Fix a bug/typo on new branch.
</p>
</li>
<li>
<p>
Make a pull-request to master.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>For New feature</strong>:</p></div>
<div class="ulist"><ul>
<li>
<p>
Open a new issue with new feature purpose.
</p>
</li>
<li>
<p>
If it is accepted, follow same steps as "bugfix".
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_faq">8. FAQ</h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>How can use <em>buddy</em> with <a href="http://clojure-liberator.github.io/liberator/">liberator</a>?</strong></p></div>
<div class="paragraph"><p><em>buddy</em> by design, has authorization and authentication concepts well separated. This
helps a lot if you want use some one part of it (ex: authentencation only) without including
other parts.</p></div>
<div class="paragraph"><p>This makes, integration with liberator very simple, because liberator comes with good
decision handlers for authorization and by normally usage, you should use it instead
of integrate other third party authorization system to liberator.</p></div>
<div class="paragraph"><p>The best combination is use <em>buddy</em> authentication middleware with liberator (using it
authorization system).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_license">9. License</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre>Copyright 2014 Andrey Antukh &lt;niwi@niwi.be&gt;

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;)
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</pre></div></div></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Version 0.1.0<br>
Last updated 2014-03-12 23:49:29 CET
</div>
</div>
</body>
</html>
